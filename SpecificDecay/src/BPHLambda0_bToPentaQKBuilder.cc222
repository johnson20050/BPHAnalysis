/*
 *  See header file for a description of this class.
 *
 *  $Date: 2015-07-24 11:29:20 $
 *  $Revision: 1.1 $
 *  \author Paolo Ronchese INFN Padova
 *
 */

//-----------------------
// This Class' Header --
//-----------------------
#include "BPHAnalysis/SpecificDecay/interface/BPHLambda0_bToPentaQKBuilder.h"

//-------------------------------
// Collaborating Class Headers --
//-------------------------------
#include "BPHAnalysis/RecoDecay/interface/BPHRecoBuilder.h"
#include "BPHAnalysis/RecoDecay/interface/BPHPlusMinusCandidate.h"
#include "BPHAnalysis/RecoDecay/interface/BPHRecoCandidate.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHParticleNeutralVeto.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHParticlePtSelect.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHParticleEtaSelect.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHMassSelect.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHChi2Select.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHMassFitSelect.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHParticleMasses.h"

//---------------
// C++ Headers --
//---------------
using namespace std;

//-------------------
// Initializations --
//-------------------


//----------------
// Constructors --
//----------------
BPHLambda0_bToPentaQKBuilder::BPHLambda0_bToPentaQKBuilder( const edm::EventSetup& es,
    const std::vector<BPHPlusMinusConstCandPtr>& PentaQCollection,
    const BPHRecoBuilder::BPHGenericCollection*    KaonCollection ):
    penQName( "PentaQ" ),
    kaonName(   "Kaon" ),
  evSetup( &es ),
  pCollection( &PentaQCollection ),
  kCollection(    KaonCollection )  {
     knVeto = new BPHParticleNeutralVeto;
      ptSel = new BPHParticlePtSelect (  0.7 );
   mPenQSel = new BPHMassSelect       ( 4.00, 5.00 );
     etaSel = new BPHParticleEtaSelect( 10.0 );
    massSel = new BPHMassSelect       ( 4.50, 6.50 );
    chi2Sel = new BPHChi2Select       ( 0.02 );
    mFitSel = new BPHMassFitSelect    ( penQName,
                                        BPHParticleMasses::penQMass,
                                        BPHParticleMasses::penQMWidth,
                                        5.00, 6.00 );
  massConstr = true;
  minPDiff = 1.0e-4;
  updated = false;
}

//--------------
// Destructor --
//--------------
BPHLambda0_bToPentaQKBuilder::~BPHLambda0_bToPentaQKBuilder() {
  delete  mPenQSel;
  delete    knVeto;
  delete     ptSel;
  delete    etaSel;
  delete   massSel;
  delete   chi2Sel;
  delete   mFitSel;
}

//--------------
// Operations --
//--------------
vector<BPHRecoConstCandPtr> BPHLambda0_bToPentaQKBuilder::build() {

  if ( updated ) return lbList;

  BPHRecoBuilder bLb( *evSetup );
  bLb.setMinPDiffererence( minPDiff );
  bLb.add( penQName, *pCollection );
  bLb.add( kaonName,  kCollection, BPHParticleMasses::kaonMass,
                                   BPHParticleMasses::kaonMSigma );
  bLb.filter(   penQName, * mPenQSel );
  bLb.filter(   kaonName, *   knVeto );
  bLb.filter(   kaonName, *    ptSel );
  bLb.filter(   kaonName, *   etaSel );

  bLb.filter( *massSel );
  bLb.filter( *chi2Sel );
  if ( massConstr ) bLb.filter( *mFitSel );

  lbList = BPHRecoCandidate::build( bLb );
//
//  Apply kinematic constraint on the JPsi mass.
//  The operation is already performed when apply the mass selection,
//  so it's not repeated. The following code is left as example
//  for similar operations
//
//  int iLb;
//  int nLb = ( massConstr ? lbList.size() : 0 );
//  for ( iLb = 0; iLb < nLb; ++iLb ) {
//    BPHRecoCandidate* cptr( const_cast<BPHRecoCandidate*>(
//                            lbList[iLb].get() ) );
//    BPHRecoConstCandPtr jpsi = cptr->getComp( jPsiName );
//    double jMass = jpsi->constrMass();
//    if ( jMass < 0 ) continue;
//    double sigma = jpsi->constrSigma();
//    cptr->kinematicTree( jPsiName, jMass, sigma );
//  }
  updated = true;
  return lbList;

}

/// set cuts
void BPHLambda0_bToPentaQKBuilder::setPentaQMassMin( double m ) {
  updated = false;
   mPenQSel->setMassMin( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setPentaQMassMax( double m ) {
  updated = false;
  mPenQSel->setMassMax( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setKPtMin( double pt ) {
  updated = false;
  ptSel->setPtMin( pt );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setKEtaMax( double eta ) {
  updated = false;
  etaSel->setEtaMax( eta );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setMassMin( double m ) {
  updated = false;
  massSel->setMassMin( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setMassMax( double m ) {
  updated = false;
  massSel->setMassMax( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setProbMin( double p ) {
  updated = false;
  chi2Sel->setProbMin( p );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setMassFitMin( double m ) {
  updated = false;
  mFitSel->setMassMin( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setMassFitMax( double m ) {
  updated = false;
  mFitSel->setMassMax( m );
  return;
}


void BPHLambda0_bToPentaQKBuilder::setConstr( bool flag ) {
  updated = false;
  massConstr = flag;
  return;
}

/// get current cuts
double BPHLambda0_bToPentaQKBuilder::getPentaQMassMin() const {
  return mPenQSel->getMassMin();
}


double BPHLambda0_bToPentaQKBuilder::getPentaQMassMax() const {
  return mPenQSel->getMassMax();
}


double BPHLambda0_bToPentaQKBuilder::getKPtMin() const {
  return ptSel->getPtMin();
}


double BPHLambda0_bToPentaQKBuilder::getKEtaMax() const {
  return etaSel->getEtaMax();
}


double BPHLambda0_bToPentaQKBuilder::getMassMin() const {
  return massSel->getMassMin();
}


double BPHLambda0_bToPentaQKBuilder::getMassMax() const {
  return massSel->getMassMax();
}


double BPHLambda0_bToPentaQKBuilder::getProbMin() const {
  return chi2Sel->getProbMin();
}


double BPHLambda0_bToPentaQKBuilder::getMassFitMin() const {
  return mFitSel->getMassMin();
}


double BPHLambda0_bToPentaQKBuilder::getMassFitMax() const {
  return mFitSel->getMassMax();
}


bool BPHLambda0_bToPentaQKBuilder::getConstr() const {
  return massConstr;
}

