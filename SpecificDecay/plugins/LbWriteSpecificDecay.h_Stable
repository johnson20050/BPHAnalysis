#ifndef BPHAnalysis_SpecificDecay_LbWriteSpecificDecay_h
#define BPHAnalysis_SpecificDecay_LbWriteSpecificDecay_h

#include "BPHAnalysis/RecoDecay/interface/BPHAnalyzerTokenWrapper.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "DataFormats/ParticleFlowCandidate/interface/PFCandidate.h"

#include "BPHAnalysis/RecoDecay/interface/BPHPlusMinusCandidate.h"
#include "BPHAnalysis/RecoDecay/interface/BPHRecoCandidate.h"
#include "BPHAnalysis/RecoDecay/interface/BPHTrackReference.h"

#include "DataFormats/Common/interface/Ref.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/PatCandidates/interface/GenericParticle.h"
#include "DataFormats/PatCandidates/interface/CompositeCandidate.h"

#include "RecoVertex/KinematicFitPrimitives/interface/RefCountedKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/RefCountedKinematicVertex.h"

#include "RecoVertex/KinematicFit/interface/TwoTrackMassKinematicConstraint.h"
#include "RecoVertex/KinematicFit/interface/KinematicConstrainedVertexFitter.h"
#include "BPHAnalysis/SpecificDecay/interface/BPHParticleMasses.h"
#include "TrackingTools/TransientTrack/interface/TransientTrack.h"

#include <string>
#include <vector>
#include <map>
#include <iostream>
#include <fstream>

class TH1F;
class BPHRecoCandidate;

class LbWriteSpecificDecay:
    public BPHAnalyzerWrapper<BPHModuleWrapper::one_producer>
{

public:

    explicit LbWriteSpecificDecay( const edm::ParameterSet& ps );
    virtual ~LbWriteSpecificDecay();

    static void fillDescriptions( edm::ConfigurationDescriptions& descriptions );

    virtual void beginJob();
    virtual void produce( edm::Event& ev, const edm::EventSetup& es );
    virtual void fill( edm::Event& ev, const edm::EventSetup& es );
    virtual void endJob();

private:


// The label used in reading data
    std::string pVertexLabel;
    std::string patMuonLabel;
    std::string ccCandsLabel;
    std::string pfCandsLabel;
    std::string pcCandsLabel;
    std::string gpCandsLabel;


    // token wrappers to allow running both on "old" and "new" CMSSW versions
    BPHTokenWrapper< std::vector<reco::Vertex>                 > pVertexToken;
    BPHTokenWrapper< pat::MuonCollection                       > patMuonToken;
    BPHTokenWrapper< std::vector<pat::CompositeCandidate     > > ccCandsToken;
    BPHTokenWrapper< std::vector<reco::PFCandidate           > > pfCandsToken;
    BPHTokenWrapper< std::vector<BPHTrackReference::candidate> > pcCandsToken;
    BPHTokenWrapper< std::vector<pat::GenericParticle        > > gpCandsToken;


    bool usePV;
    bool usePM;
    bool useCC;
    bool usePF;
    bool usePC;
    bool useGP;

// The label used in output product
    std::string     oniaName;
    std::string     Lam0Name;
    std::string LbToLam0Name;
    std::string LbToTkTkName;

    enum recoType { Onia, JPsi, Psi2, Lam0, LbToLam0, LbToTkTk };
    enum  parType { ptMin, etaMax,
                    mPsiMin, mPsiMax, mLam0Min, mLam0Max,
                    massMin, massMax, probMin, mFitMin, mFitMax,
                    constrMass, constrSigma, constrMJPsi, writeCandidate,
                    compCharge
                  };

    std::map<std::string,recoType> rMap;
    std::map<std::string, parType> pMap;
    std::map<std::string, parType> fMap;
    std::map< recoType, std::map<parType,double> >  parMap;


    bool recoOnia     ;
    bool recoLam0     ;
    bool recoLbToLam0 ;
    bool recoLbToTkTk ;

    bool writeOnia    ;
    bool writeLam0    ;
    bool writeLbToLam0;
    bool writeLbToTkTk;

    bool writeVertex;
    bool writeMomentum;

    std::vector<BPHPlusMinusConstCandPtr> lFull;
    std::vector<BPHPlusMinusConstCandPtr> lJPsi;
    std::vector<BPHPlusMinusConstCandPtr> lLam0;
    std::vector<BPHRecoConstCandPtr>      lLbToLam0;
    std::vector<BPHRecoConstCandPtr>      lLbToTkTk;

    std::map<const BPHRecoCandidate*,const BPHRecoCandidate*> jPsiOMap;
    typedef edm::Ref< std::vector<reco::Vertex> > vertex_ref;
    std::map<const BPHRecoCandidate*,vertex_ref> pvRefMap;
    typedef edm::Ref< pat::CompositeCandidateCollection > compcc_ref;
    std::map<const BPHRecoCandidate*,compcc_ref> ccRefMap;
    std::map<const BPHRecoCandidate*,const BPHRecoCandidate*> secVtxParticleMap;

    int totnum;
    int totnumx;


    void setRecoParameters( const edm::ParameterSet& ps );

    template <class T>
    edm::OrphanHandle<pat::CompositeCandidateCollection> write( edm::Event& ev,
            const std::vector<T>& list, const std::string& name , 
            bool useJpsiConstrVertexFit = false) 
            //bool approveSecondaryReconstruction = false)
    {
        pat::CompositeCandidateCollection* ccList =
            new pat::CompositeCandidateCollection;
        int i;
        int n = list.size();

        std::map<const BPHRecoCandidate*,
            const BPHRecoCandidate*>::const_iterator jpoIter;
        std::map<const BPHRecoCandidate*,
            const BPHRecoCandidate*>::const_iterator jpoIend = jPsiOMap.end();
        std::map<const BPHRecoCandidate*,vertex_ref>::const_iterator pvrIter;
        std::map<const BPHRecoCandidate*,vertex_ref>::const_iterator pvrIend =
            pvRefMap.end();
        std::map<const BPHRecoCandidate*,compcc_ref>::const_iterator ccrIter;
        std::map<const BPHRecoCandidate*,compcc_ref>::const_iterator ccrIend =
            ccRefMap.end();
        for ( i = 0; i < n; ++i )
        {
            const T& ptr = list[i];
            ccList->push_back( ptr->composite() );
            pat::CompositeCandidate& cc = ccList->back();
            if ( ( pvrIter = pvRefMap.find( ptr.get() ) ) != pvrIend )
                cc.addUserData ( "primaryVertex", pvrIter->second );
            const std::vector<std::string>& cNames = ptr->compNames();




            int j = 0;
            int m = cNames.size();

// Find out ccrIter and ccrIter in JpsoIter from input list[], the record it {{{
            // if find ccrIter, record it
            // &&
            // if fint ccrIter recorded in JpsoIter, record it, too.
            // Input a particle,  Add reference subparticle.
            //    first find out the name of subparticle.
            //    second search for the map, what is map of the subparticle stored.
            //    if find out the map stored. add the ref-subparticle to UserData.
            while ( j < m )
            {
                const std::string& compName = cNames[j++];
                const BPHRecoCandidate* cptr = ptr->getComp( compName ).get();
                if ( ( ccrIter = ccRefMap.find( cptr ) ) == ccrIend )
                {
                    if ( ( jpoIter = jPsiOMap.find( cptr ) ) != jpoIend )
                        cptr = jpoIter->second;
                    else cptr = 0;
                }
                if ( ( ccrIter = ccRefMap.find( cptr ) ) != ccrIend )
                {
                    compcc_ref cref = ccrIter->second;
                    if ( cref.isNonnull() ) cc.addUserData ( "refTo" + compName, cref );
                }
            }
// Find out ccrIter and ccrIter in JpsoIter, the record it end }}}
            const BPHPlusMinusCandidate* pmp =
                dynamic_cast<const BPHPlusMinusCandidate*>( ptr.get() );
            if ( pmp != 0 ) cc.addUserData( "cowboy", pmp->isCowboy() );
            if ( ptr->isEmpty() )
            {
                if ( writeVertex ) cc.addUserData( "vertex" , ptr->vertex() );
                continue;
            }


// My jpsi constraint fitVertex
                
            if ( useJpsiConstrVertexFit )
            {
                ParticleMass jpsi_mass = 3.096916;
                TwoTrackMassKinematicConstraint *jpsi_const = new TwoTrackMassKinematicConstraint(jpsi_mass);
                RefCountedKinematicTree compTree = ptr.get()->kinematicTree("JPsi", jpsi_const);
                if ( writeVertex ) cc.addUserData( "fitVertex", reco::Vertex( *compTree->currentDecayVertex() ) );
                if ( ptr->isValidFit() )
                {
                    const RefCountedKinematicParticle kinPart = compTree->currentParticle();
                    const           KinematicState    kinStat = kinPart->currentState();
                    cc.addUserFloat( "fitMass", kinStat.mass() );
                    cc.addUserData ( "fitMomentum",
                                     kinStat.kinematicParameters().momentum() );
                }

                // store transient track to fit at further analysis
                
                //const BPHRecoCandidate* cand = ptr.get();
                //const BPHRecoCandidate* cand_jpsi = ptr->getComp( "JPsi"   ).get();
                //const std::vector<std::string>& jpsidNames = cand_jpsi->daugNames();
                //std::cout << "jpsi daught name 1: " << jpsidNames[0] << ",  jpsi daughter name 2: " << jpsidNames[1] << std::endl;
                //std::vector<std::string>::const_iterator iter = jpsidNames.begin();
                //std::vector<std::string>::const_iterator iend = jpsidNames.end  ();
                //while ( iter != iend )
                //{
                //    const std::string& daugName = *iter++;
                //    const reco::TransientTrack* tDaug  =cand_jpsi->getTransientTrack(  cand_jpsi->getDaug( daugName )  );
                //    cc.addUserData ( "transientTrackTo" + daugName, *tDaug );
                //}

                //const std::vector<std::string>& dNames = cand->daugNames();
                //std::vector<std::string>::const_iterator iTer = dNames.begin();
                //std::vector<std::string>::const_iterator iEnd = dNames.end  ();
                //while ( iTer != iEnd )
                //{
                //    const std::string& daugName = *iTer++;
                //    const reco::TransientTrack* tDaug  =cand->getTransientTrack(  cand->getDaug( daugName )  );
                //    cc.addUserData ( "transientTrackTo" + daugName, *tDaug );
                //}



                //bool approveSecondaryReconstruction = true;
                //if ( approveSecondaryReconstruction )
                //{
                //    const BPHRecoCandidate* cand = ptr.get();
                //    const reco::Candidate* mPos   = cand->originalReco(
                //                                    cand->getDaug( "JPsi/MuPos" ) );
                //    const reco::Candidate* mNeg   = cand->originalReco(
                //                                    cand->getDaug( "JPsi/MuNeg" ) );
                //    const reco::Candidate* proton = cand->originalReco(
                //                                    cand->getDaug( "Proton"     ) );
                //    BPHRecoCandidatePtr njp( new BPHPlusMinusCandidate( &es ) );
                //    njp->add( "MuPos", mPos,
                //              BPHParticleMasses::muonMass,
                //              BPHParticleMasses::muonMSigma );
                //    njp->add( "MuNeg", mNeg,
                //              BPHParticleMasses::muonMass,
                //              BPHParticleMasses::muonMSigma );
                //    BPHRecoCandidate nSecFit( &es );
                //    nSecFit.add( "JPsi", njp );
                //    nSecFit.add( "Proton", proton,
                //              BPHParticleMasses::protonMass,
                //              BPHParticleMasses::protonMSigma );
                //    compTree = nSecFit.kinematicTree( "JPsi", jpsi_const );
                //    RefCountedKinematicTree compTree = ptr.get()->kinematicTree("JPsi", jpsi_const);
                //    if ( writeVertex i cc.addUserData( "secfitVertex", reco::Vertex( *compTree->currentDecayVertex() ) );
                //    if ( ptr->isValidFit() )
                //    {
                //        const RefCountedKinematicParticle kinPart = compTree->currentParticle();
                //        const           KinematicState    kinStat = kinPart->currentState();
                //        cc.addUserFloat( "secfitMass", kinStat.mass() );
                //        cc.addUserData ( "secfitMomentum",
                //                         kinStat.kinematicParameters().momentum() );
                //    }
                //}
            }
            else
            {
                if ( writeVertex ) cc.addUserData( "fitVertex", reco::Vertex( *ptr->currentDecayVertex() ) );
                if ( ptr->isValidFit() )
                {
                    const RefCountedKinematicParticle kinPart = ptr->currentParticle();
                    const           KinematicState    kinStat = kinPart->currentState();
                    cc.addUserFloat( "fitMass", kinStat.mass() );
                    cc.addUserData ( "fitMomentum",
                                     kinStat.kinematicParameters().momentum() );

                }
            }

        }
        typedef std::unique_ptr<pat::CompositeCandidateCollection> ccc_pointer;
        edm::OrphanHandle<pat::CompositeCandidateCollection> ccHandle =
            ev.put( ccc_pointer( ccList ), name );
        for ( i = 0; i < n; ++i )
        {
            const BPHRecoCandidate* ptr = list[i].get();
            edm::Ref<pat::CompositeCandidateCollection> ccRef( ccHandle, i );
            ccRefMap[ptr] = ccRef;
        }
        return ccHandle;
    }

    //template <class T>
    //edm::OrphanHandle<pat::CompositeCandidateCollection> writeSecondaryReconstruction( edm::Event& ev,
    //        const std::vector<T>& list, const std::string& name , bool useJpsiConstrVertexFit = false)
    //{
    //}
};

#endif
